## 一、输入/输出流

C++ 用于输入/输出的头文件是：

1. `iostream`：`iostream` 代表标准输入输出流。该头文件包含诸如 `cin`、`cout`、`cerr `等对象的定义。
2. `iomanip`：`iomanip` 代表输入输出操纵器。这些文件中声明的方法用于操作流。该文件包含 `setw`、`setprecision` 等的定义。
3. `fstream`：这个头文件主要是描述文件流。此头文件用于处理从文件中读取的数据作为输入或数据写入文件作为输出。
4. `bits/stdc++`：这个头文件包含了所有的标准库。



`iostream` 类的 C++ 中的两个实例 `cout` 和 C++ 中的 `cin` 经常分别用于打印输出和获取输入。这两个是 C++ 中最基本的获取输入和打印输出的方法。要在 C++ 中使用 `cin` 和 `cout`，必须在程序中包含头文件 `iostream`。



### 1. Standard output stream ( `cout ` )

标准输出流（ `cout` ）：通常标准输出设备是显示屏。 C++ `cout` 语句是 `ostream` 类的实例。它用于在通常是显示屏的标准输出设备上产生输出。使用插入运算符（ `<<` ）将需要显示在屏幕上的数据插入到标准输出流（ `cout` ）中。



### 2. Standard input stream ( `cin` )

标准输出流（ `cin` ）通常计算机中的输入设备是键盘。 C++ `cin` 语句是 `istream` 类的实例，用于从标准输入设备（通常是键盘）读取输入。

提取运算符 ( `>>` ) 与对象 `cin` 一起用于读取输入。提取运算符从使用键盘输入的对象 `cin` 中提取数据。



### 3. Un-buffered standard error stream ( `cerr` )

未缓冲的标准错误流 ( `cerr` )：C++ `cerr` 是用于输出错误的标准错误流。这也是 `iostream` 类的一个实例。由于 C++ 中的 `cerr` 是非缓冲的，因此在需要立即显示错误消息时使用它。**它没有任何缓冲区来存储错误消息并稍后显示**。

`cerr` 和 `cout` 之间的主要区别在于，当您想使用 `cout` 重定向输出时，如果您使用`cerr` ，则该输出将被重定向到文件，错误不会存储在文件中。（这就是无缓冲的意思......它无法存储消息）。

```c++
// test.cpp
#include
using namespace std;

int main()
{
    cout << “hello world—cout” << endl ;
    cerr << “hello world—cerr” << endl ;
    return 0;
}
```

在命令行模式下键入下面的命令： 

```shell
test >> cout.txt
```

运行结果是：
在生成的 cout.txt 文件中输出了" hello world—cout " ，
同时在显示器上输出了" hello world—cerr " ，
也就是说 `cout` 的输出可以重定向到一个文件中，而 `cerr` 必须输出在显示器上。



**为什么要用 `cerr`？**
比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归）。
你说，你到什么地方借内存，存放你的 错误信息？
所以有了 `cerr` 。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持。 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。



### 4. Buffered standard error stream ( `clog` )

这也是 `ostream` 类的一个实例，用于显示错误，但与 `cerr` 不同的是，错误首先被插入到缓冲区中并存储在缓冲区中，直到它没有被完全填满。或者缓冲区未显式刷新（使用 `flush()` ）。错误消息也会显示在屏幕上。



### 5. C++ 中的 `endl` 与 `\n`

`cout << endl` 插入一个新行并刷新流（输出缓冲区），而 `cout << "\n"` 只是插入一个新行。

因此，`cout << endl;` 可以说等同于 `cout << ‘\n’ << flush;`

|                         endl                         |                            \n                            |
| :--------------------------------------------------: | :------------------------------------------------------: |
|        It is a manipulator.  它是一个操纵器。        |            It is a character. 它是一个字符。             |
|                  它不占用任何内存。                  |           它是一个字符，占用 1 个字节的内存。            |
| 它是一个关键字，当存储在字符串中时不会指定任何含义。 | 它可以存储在一个字符串中，仍然会传达其换行符的特定含义。 |
|            我们不能在双引号之间写‘endl’。            |      我们可以在双引号之间写‘\n’，比如 cout<<“\n”；       |
|                  它仅受 C++ 支持。                   |                   C 和 C++ 都支持它。                    |
|      它在整个过程中不断刷新输出缓冲区中的队列。      |            它只在程序结束时刷新输出缓冲区一次            |

使用 `\n` 效率高于 `endl` 参考文献 [Why we should avoid using std::endl - GeeksforGeeks --- 为什么我们应该避免使用 std::endl - GeeksforGeeks](https://www.geeksforgeeks.org/avoid-using-stdendl/?ref=rp)



## 二、C++ 数据类型

### 1. 基础数据类型

| 名称           | 32位 字节长度 | 64位 字节长度 |
| -------------- | ------------- | ------------- |
| *p             | 4             | 8             |
| bool           | 1             | 1             |
| char           | 1             | 1             |
| signed char    | 1             | 1             |
| unsigned char  | 1             | 1             |
| short          | 2             | 2             |
| unsigned short | 2             | 2             |
| wchar_t        | 2             | 2             |
| int            | 4             | 4             |
| unsigned int   | 4             | 4             |
| long           | 4             | 8             |
| unsigned long  | 4             | 8             |
| long long      | 8             | 8             |
| double         | 8             | 8             |
| long double    | 10/12         | 10/16         |
| float          | 4             | 4             |
| size_t         | 4             | 8             |

> wchar_t : `typedef short int wchar_t;`
>
> 
>
> size_t : 使用 size_t 可能会提高代码的可移植性、有效性或者可读性。
>
> 参看《[size_t详解](https://blog.csdn.net/qq_34018840/article/details/100884317)》
>
> 在标准 C 库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如 `malloc(n)` 函数的参数 n 指明了需要申请的空间大小、`memcpy(s1, s2, n)` 的最后一个参数表明需要复制的内存大小、`strlen(s)` 函数的返回值表明了以 `'\0'` 结尾的字符串的长度（不包括 `'\0'` ）。
>
> 或许你会认为这些参数或者返回值应该被申明为 int 类型（或者 long 或者 unsigned ），但是事实上并不是。C 标准中将他们定义为size_t 。标准中记载 malloc、memcpy 和strlen 的声明：
>
> ```cpp
> //malloc()
> void *malloc(size_t n);
> 
> //memcpy()
> void *memcpy(void *s1, void const *s2, size_t n);
> 
> //strlen()
> size_t strlen(char const *s);
> ```



### 2. uint8_t 等

由于不同编译器对基本数量类型占有内存设计不同，为了提高代码的可移植性，引入了 uint8_t 、uint16_t、uint32_t 等，而 `*_t` 是 typedef 定义的表示标志，因此上述类型只是 typedef 起的别名。

```cpp
typedef signed char             int8_t;
typedef short int               int16_t;
typedef int                     int32_t;

typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
typedef unsigned int            uint32_t;
```



## 二、C++ 内存分配

### 1. C 语言中内存分配

- 栈（stack）：用来存放**函数形参**和函数内的**局部变量**。由**编译器分配空间**，在函数执行完后由编译器自动释放

- 堆（heap）：用来存放由动态分配函数（如 malloc）分配的空间。是由程序员自己手动分配和需要手动 free，容易导致内存泄露

- 全局区/静态区：用来存放**全局变量**和**静态变量**。程序结束时由系统释放，分为全局初始区和全局未初始化区；存在于**程序的整个运行期间，是由编译器分配和释放**的

- 文字常量区：常量字符串放于此，程序结束时由系统释放。也**由编译器分配和释放**

  > `char * c = "123456";` 则 "123456" 为文字常量，存放于文字常量区

- 程序代码区：用来存放程序的二进制代码

示例1：

```c
int a = 0; // 全局初始化区
char *p1; // 全局未初始化区

void main() {
    int b;  // 栈
    char s[] = "abc";  // s在栈，"abc\0"在文字常量区
    char *p2;  // 栈
    char *p3 = "123456";  // p3在栈，"123456\0"在文字常量区
    static int c = 0;   // 全局区
    p1 = (char *) malloc(10);  // p1在栈，分配的10个字节在堆
    p2 = (char *) malloc(20);  // p2在栈，分配的10个字节在堆
    strcpy(p1, "123456");  // ”123456“在文字常量区，编译器可能会有优化为和p3的指向同一块区域
}
```

示例2：

```c
char *f() {
    char s[4] = {'1', '2', '3', '0'};  // s 数组存放在栈上
    return s; // 返回 s 数组的地址，但程序运行完 s 数组就释放了
}

void main() {
    char *s;
    s = f();
    printf(%s, s);  // 打印出来乱码。因为 s 所指向地址已经没有数据
}
```

### 2. C++ 中内存分配

- 栈：由编译器自动分配和释放。通常存放**局部变量**和**函数参数**

- 堆：由 malloc 等分配的内存块，和堆十分类似，不过它由 free 来结束自己的生命

- 自由存储区：由 new 分配的内存块，由应用程序控制申请和释放。如果程序员没有释放掉，那么程序结束后，操作系统会自动回收

  > 内存泄漏不是系统无法回收那片内存，而是你自己的应用程序无法使用那片内存。当你程序结束时，你所有分配的内存自动都被系统回收，不存在泄漏问题。但是在你**程序的生命期内**，如果你分配的内存都不回收，你将很快没内存使用

- 全局/静态存储区：**全局变量**和**静态变量**被分配到同一块内存中。在 C 语言中，全局变量又分为初始化和未初始化的，在 C++ 里面没有这个区分了，它们共用同一块内存区。

- 常量存储区：这是一块特殊的存储区，他们里面存放的是常量，不允许修改（非正当手段可以修改）



**《Unix 环境高级编程》中提出 C 程序的内存布局： Text、Data、BSS、Stack，Heap**

- Text 是程序的代码段
- Data 是程序中初始化了的全局、静态数据变量
- BSS 是程序中未初始化的全局/静态数据变量。即使全局、静态数据变量初始化为 0 仍然是属于 BSS 段 （未初始化的数据段）
- Stack 是程序中的局部变量，栈向下，向低地址方向增长
- Heap 是 malloc 调用动态分配的内存，堆向上，向向高地址方向增长

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230313101133517.png" alt="image-20230313101133517" style="zoom: 60%;" />

详细参看《[C++ 堆区，栈区，数据段，bss段，代码区](https://blog.csdn.net/JACKSONMHLK/article/details/114392343)》









