## 一、C++ 数据类型

### 1. 基础数据类型

| 名称           | 32位 字节长度 | 64位 字节长度 |
| -------------- | ------------- | ------------- |
| *p             | 4             | 8             |
| bool           | 1             | 1             |
| char           | 1             | 1             |
| signed char    | 1             | 1             |
| unsigned char  | 1             | 1             |
| short          | 2             | 2             |
| unsigned short | 2             | 2             |
| wchar_t        | 2             | 2             |
| int            | 4             | 4             |
| unsigned int   | 4             | 4             |
| long           | 4             | 8             |
| unsigned long  | 4             | 8             |
| long long      | 8             | 8             |
| double         | 8             | 8             |
| long double    | 10/12         | 10/16         |
| float          | 4             | 4             |
| size_t         | 4             | 8             |

> wchar_t : `typedef short int wchar_t;`
>
> 
>
> size_t : 使用 size_t 可能会提高代码的可移植性、有效性或者可读性。
>
> 参看《[size_t详解](https://blog.csdn.net/qq_34018840/article/details/100884317)》
>
> 在标准 C 库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如 `malloc(n)` 函数的参数 n 指明了需要申请的空间大小、`memcpy(s1, s2, n)` 的最后一个参数表明需要复制的内存大小、`strlen(s)` 函数的返回值表明了以 `'\0'` 结尾的字符串的长度（不包括 `'\0'` ）。
>
> 或许你会认为这些参数或者返回值应该被申明为 int 类型（或者 long 或者 unsigned ），但是事实上并不是。C 标准中将他们定义为size_t 。标准中记载 malloc、memcpy 和strlen 的声明：
>
> ```cpp
> //malloc()
> void *malloc(size_t n);
> 
> //memcpy()
> void *memcpy(void *s1, void const *s2, size_t n);
> 
> //strlen()
> size_t strlen(char const *s);
> ```



### 2. uint8_t 等

由于不同编译器对基本数量类型占有内存设计不同，为了提高代码的可移植性，引入了 uint8_t 、uint16_t、uint32_t 等，而 `*_t` 是 typedef 定义的表示标志，因此上述类型只是 typedef 起的别名。

```cpp
typedef signed char             int8_t;
typedef short int               int16_t;
typedef int                     int32_t;

typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
typedef unsigned int            uint32_t;
```



## 三、GCC

### 1. GCC 工作流程

![image-20230322212020075](D:\Data\笔记\c++\c++基础知识.assets\image-20230322212020075.png)

### 2. GCC 编译选项

| GCC 编译选项                            | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| -E                                      | 预处理指定的源文件，不进行编译                               |
| -S                                      | 编译指定的源文件，但是不进行汇编                             |
| -c                                      | 编译、汇编指定的源文件，但是不进行链接                       |
| [file2] -o [file1] / -o [file1] [file2] | 将文件 file2 编译成可执行文件 file1                          |
| -I directorcy                           | （大写 i ）指定 include 包含文件的搜索目录                   |
| -g                                      | 在编译的时候，生成调试信息，该程序可以被调试器调试           |
| -D                                      | 在程序编译的时候，指定一个宏                                 |
| -w                                      | 不生成任何警告信息                                           |
| -Wall                                   | 生成所有警告信息                                             |
| -On                                     | n的取值范围：0~3。编译器的优化选项的4个级别，-O0表 示没有优化，-O1为缺省值，-O3优化级别最高 |
| -l                                      | （小写 L）在程序编译的时候，指定使用的库                     |
| -L                                      | 指定编译的时候，搜索的库的路径                               |
| -fPIC/fpic                              | 生成与位置无关的代码                                         |
| -shared                                 | 生成共享目标文件，通常用在建立共享库时                       |
| -std                                    | 指定C方言，如:-std=c99，gcc默认的方言是GNU C                 |

### 3. GCC 和 G++ 的区别

gcc 和 g++ 都是 GNU（组织）的一个编译器。

**误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码**。

两者都可以，请注意： 

- 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 

- 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 

- 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的

**误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会** 

实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释

如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则， 就是已定义 

**误区三：编译只能用 gcc，链接只能用 g++**

- 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++。
- gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价



## 四、库文件

### 1. 什么是库

库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 

库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。

库文件有两种，静态库和动态库（共享库），区别是：静**态库在程序的链接阶段被复制到了程序中**；**动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用**。

库的好处

① 代码保密  ②方便部署和分发

静态库: GCC 进行链接时，会把静态库中代码打包到可执行程序中

动态库: GCC 进行链接时，动态库的代码不会被打包到可执行程序中

程序启动之后，动态库会被动态加载到内存中，通过  ldd （list dynamic dependencies）命令检查动态库依赖关系

**如何定位共享库文件呢？**

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要**系统的动态载入器来获取该绝对路径**。对于 elf 格式的可执行程序，是由 ld-linux.so 来完成的，它先后搜索 elf 文件的 DT_ RPATH 段->环境变量 LD_LIBRARY_PATH 一> /etc/ld.so.cache 文件列表 一> /lib/, /usr/lib 目录找到库文件后将其载入内存。

### 2. 静态库的制作

**命名规则**

- Linux：libxxx.a
  - lib：前缀（固定）
  - xxx：库的名字，自己起
  - .a：后缀（固定）
- Windows：libxxx.lib

**静态库的制作**

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323163110332.png" alt="image-20230323163110332" style="zoom:67%;" />

- gcc 获得 .o 文件

- 将 .o 文件打包，使用 ar 工具（archive）

  ```shell
  ar rcs libxxx.a xxx.o xxx.o
  # r - 将文件插入备存文件中
  # c - 建立备存文件
  # s - 索引
  ```

### 3. 动态库的制作

**命名规则**

- Linux：libxxx.so
  - lib：前缀（固定）
  - xxx：库的名字，自己起
  - .so：后缀（固定）
- Windows：libxxx.dll

**动态库的制作**

- gcc 获得 .o 文件，得到和位置无关的代码

  ```shell
  gcc -c -fpic/-fPIC a.c b.c
  ```

- gcc 得到动态库

  ```shell
  gcc -shared a.o b.o -o libcalc.so
  ```

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323163144929.png" alt="image-20230323163144929" style="zoom:67%;" />

### 4. 静态库和动态库的对比

**程序编译成可执行程序的过程**

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323162838236.png" alt="image-20230323162838236" style="zoom: 67%;" />

**静态库的优缺点**

- 优点
  - 静态库被打包到应用程序中加载速度快
  - 发布程序无需提供静态库，移植方便
- 缺点
  - 消耗系统资源，浪费内存
  - 更新、部署、发布麻烦

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323171354110.png" alt="image-20230323171354110" style="zoom:67%;" />

**动态库的优缺点**

- 优点
  - 可以实现进程间资源共享（共享库）
  - 更新、部署、发布简单
  - 可以控制何时加载动态库
- 缺点
  - 加载速度比静态库慢
  - 发布程序时需要提供依赖的动态库

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323171909546.png" alt="image-20230323171909546" style="zoom:67%;" />



## 五、Makefile

### 1. 什么是 Makefile

- 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中， Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 文件就像一个 Shell 脚本一样，也可以执行操作系统的命令。

- Makefile 带来的好处就是 “自动化编译” ，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如 Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。

### 2. Makefile 的规则

**文件命名**

makefile 或者 Makefile

**Makefile 规则**

- 一个 Makefile 文件中可以有一个或多个规则

  ```shell
  目标 ...: 依赖 ...
  	命令（shell 命令）
  	...
  ```

  目标：最终要生成的文件（伪目标除外）

  依赖：生成目标所需要的文件或是目标

  命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）

- Makefile 中的其它规则一般都是为第一条规则服务的

- 命令执行前，需要先检查规则中的依赖是否存在

  - 如果存在，执行命令
  - 如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的， 如果找到了，则执行该规则中的命令

- 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间

  - 如果依赖的时间比目标的时间晚，需要重新生成目标
  - 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被 执行

**变量**

![image-20230324142135991](D:\Data\笔记\c++\c++基础知识.assets\image-20230324142135991.png)

![image-20230324142152849](D:\Data\笔记\c++\c++基础知识.assets\image-20230324142152849.png)

**函数**

![image-20230324142215289](D:\Data\笔记\c++\c++基础知识.assets\image-20230324142215289.png)

![image-20230324142228079](D:\Data\笔记\c++\c++基础知识.assets\image-20230324142228079.png)



## 六、GDB 调试

### 1. 什么 GDB

GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。 

一般来说，GDB 主要帮助你完成下面四个方面的功能： 

1. 启动程序，可以按照自定义的要求随心所欲的运行程序 
2. 可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）
3. 当程序被停住时，可以检查此时程序中所发生的事
4. 可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG

### 2. 准备工作

通常，在为调试而编译时，我们会关掉编译器的优化选项（`-O`）， 并打开调试选项（`-g`）。另外，`-Wall` 在尽量不影响程序行为的情况下选项打开所有 warning，也可以发现许多问题，避免一些不必要的 BUG。 

```shell
gcc -g -Wall program.c -o program 
```

`-g` 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机 器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调 试时必须保证 gdb 能找到源文件。

### 3. GDB 命令

![image-20230324160642804](D:\Data\笔记\c++\c++基础知识.assets\image-20230324160642804.png)

![image-20230324160652841](D:\Data\笔记\c++\c++基础知识.assets\image-20230324160652841.png)

![image-20230324160709122](D:\Data\笔记\c++\c++基础知识.assets\image-20230324160709122.png)



## 七、文件 IO

### 1. 标准 C 库 IO

![image-20230326133451378](D:\Data\笔记\c++\c++基础知识.assets\image-20230326133451378.png)

### 2. 标准 C 库 IO 和 Linux 系统 IO 的关系

![image-20230326133517670](D:\Data\笔记\c++\c++基础知识.assets\image-20230326133517670.png)

### 3. 虚拟地址空间

![image-20230326133606718](D:\Data\笔记\c++\c++基础知识.assets\image-20230326133606718.png)

### 4. 文件描述符

![image-20230326133634157](D:\Data\笔记\c++\c++基础知识.assets\image-20230326133634157.png)