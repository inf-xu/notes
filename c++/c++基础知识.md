## 一、输入/输出流

C++ 用于输入/输出的头文件是：

1. `iostream`：`iostream` 代表标准输入输出流。该头文件包含诸如 `cin`、`cout`、`cerr `等对象的定义。
2. `iomanip`：`iomanip` 代表输入输出操纵器。这些文件中声明的方法用于操作流。该文件包含 `setw`、`setprecision` 等的定义。
3. `fstream`：这个头文件主要是描述文件流。此头文件用于处理从文件中读取的数据作为输入或数据写入文件作为输出。
4. `bits/stdc++`：这个头文件包含了所有的标准库。



`iostream` 类的 C++ 中的两个实例 `cout` 和 C++ 中的 `cin` 经常分别用于打印输出和获取输入。这两个是 C++ 中最基本的获取输入和打印输出的方法。要在 C++ 中使用 `cin` 和 `cout`，必须在程序中包含头文件 `iostream`。



### 1. Standard output stream ( `cout ` )

标准输出流（ `cout` ）：通常标准输出设备是显示屏。 C++ `cout` 语句是 `ostream` 类的实例。它用于在通常是显示屏的标准输出设备上产生输出。使用插入运算符（ `<<` ）将需要显示在屏幕上的数据插入到标准输出流（ `cout` ）中。



### 2. Standard input stream ( `cin` )

标准输出流（ `cin` ）通常计算机中的输入设备是键盘。 C++ `cin` 语句是 `istream` 类的实例，用于从标准输入设备（通常是键盘）读取输入。

提取运算符 ( `>>` ) 与对象 `cin` 一起用于读取输入。提取运算符从使用键盘输入的对象 `cin` 中提取数据。



### 3. Un-buffered standard error stream ( `cerr` )

未缓冲的标准错误流 ( `cerr` )：C++ `cerr` 是用于输出错误的标准错误流。这也是 `iostream` 类的一个实例。由于 C++ 中的 `cerr` 是非缓冲的，因此在需要立即显示错误消息时使用它。**它没有任何缓冲区来存储错误消息并稍后显示**。

`cerr` 和 `cout` 之间的主要区别在于，当您想使用 `cout` 重定向输出时，如果您使用`cerr` ，则该输出将被重定向到文件，错误不会存储在文件中。（这就是无缓冲的意思......它无法存储消息）。

```c++
// test.cpp
#include
using namespace std;

int main()
{
    cout << “hello world—cout” << endl ;
    cerr << “hello world—cerr” << endl ;
    return 0;
}
```

在命令行模式下键入下面的命令： 

```shell
test >> cout.txt
```

运行结果是：
在生成的 cout.txt 文件中输出了" hello world—cout " ，
同时在显示器上输出了" hello world—cerr " ，
也就是说 `cout` 的输出可以重定向到一个文件中，而 `cerr` 必须输出在显示器上。



**为什么要用 `cerr`？**
比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归）。
你说，你到什么地方借内存，存放你的 错误信息？
所以有了 `cerr` 。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持。 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。



### 4. Buffered standard error stream ( `clog` )

这也是 `ostream` 类的一个实例，用于显示错误，但与 `cerr` 不同的是，错误首先被插入到缓冲区中并存储在缓冲区中，直到它没有被完全填满。或者缓冲区未显式刷新（使用 `flush()` ）。错误消息也会显示在屏幕上。



### 5. C++ 中的 `endl` 与 `\n`

`cout << endl` 插入一个新行并刷新流（输出缓冲区），而 `cout << "\n"` 只是插入一个新行。

因此，`cout << endl;` 可以说等同于 `cout << ‘\n’ << flush;`

|                         endl                         |                            \n                            |
| :--------------------------------------------------: | :------------------------------------------------------: |
|        It is a manipulator.  它是一个操纵器。        |            It is a character. 它是一个字符。             |
|                  它不占用任何内存。                  |           它是一个字符，占用 1 个字节的内存。            |
| 它是一个关键字，当存储在字符串中时不会指定任何含义。 | 它可以存储在一个字符串中，仍然会传达其换行符的特定含义。 |
|            我们不能在双引号之间写‘endl’。            |      我们可以在双引号之间写‘\n’，比如 cout<<“\n”；       |
|                  它仅受 C++ 支持。                   |                   C 和 C++ 都支持它。                    |
|      它在整个过程中不断刷新输出缓冲区中的队列。      |            它只在程序结束时刷新输出缓冲区一次            |

使用 `\n` 效率高于 `endl` 参考文献 [Why we should avoid using std::endl - GeeksforGeeks --- 为什么我们应该避免使用 std::endl - GeeksforGeeks](https://www.geeksforgeeks.org/avoid-using-stdendl/?ref=rp)



## 二、C++ 数据类型

### 1. 基础数据类型

| 名称           | 32位 字节长度 | 64位 字节长度 |
| -------------- | ------------- | ------------- |
| *p             | 4             | 8             |
| bool           | 1             | 1             |
| char           | 1             | 1             |
| signed char    | 1             | 1             |
| unsigned char  | 1             | 1             |
| short          | 2             | 2             |
| unsigned short | 2             | 2             |
| wchar_t        | 2             | 2             |
| int            | 4             | 4             |
| unsigned int   | 4             | 4             |
| long           | 4             | 8             |
| unsigned long  | 4             | 8             |
| long long      | 8             | 8             |
| double         | 8             | 8             |
| long double    | 10/12         | 10/16         |
| float          | 4             | 4             |
| size_t         | 4             | 8             |

> wchar_t : `typedef short int wchar_t;`
>
> 
>
> size_t : 使用 size_t 可能会提高代码的可移植性、有效性或者可读性。
>
> 参看《[size_t详解](https://blog.csdn.net/qq_34018840/article/details/100884317)》
>
> 在标准 C 库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如 `malloc(n)` 函数的参数 n 指明了需要申请的空间大小、`memcpy(s1, s2, n)` 的最后一个参数表明需要复制的内存大小、`strlen(s)` 函数的返回值表明了以 `'\0'` 结尾的字符串的长度（不包括 `'\0'` ）。
>
> 或许你会认为这些参数或者返回值应该被申明为 int 类型（或者 long 或者 unsigned ），但是事实上并不是。C 标准中将他们定义为size_t 。标准中记载 malloc、memcpy 和strlen 的声明：
>
> ```cpp
> //malloc()
> void *malloc(size_t n);
> 
> //memcpy()
> void *memcpy(void *s1, void const *s2, size_t n);
> 
> //strlen()
> size_t strlen(char const *s);
> ```



### 2. uint8_t 等

由于不同编译器对基本数量类型占有内存设计不同，为了提高代码的可移植性，引入了 uint8_t 、uint16_t、uint32_t 等，而 `*_t` 是 typedef 定义的表示标志，因此上述类型只是 typedef 起的别名。

```cpp
typedef signed char             int8_t;
typedef short int               int16_t;
typedef int                     int32_t;

typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
typedef unsigned int            uint32_t;
```



## 三、C++ 内存分配

### 1. C 语言中内存分配

- 栈（stack）：用来存放**函数形参**和函数内的**局部变量**。由**编译器分配空间**，在函数执行完后由编译器自动释放

- 堆（heap）：用来存放由动态分配函数（如 malloc）分配的空间。是由程序员自己手动分配和需要手动 free，容易导致内存泄露

- 全局区/静态区：用来存放**全局变量**和**静态变量**。程序结束时由系统释放，分为全局初始区和全局未初始化区；存在于**程序的整个运行期间，是由编译器分配和释放**的

- 文字常量区：常量字符串放于此，程序结束时由系统释放。也**由编译器分配和释放**

  > `char * c = "123456";` 则 "123456" 为文字常量，存放于文字常量区

- 程序代码区：用来存放程序的二进制代码

示例1：

```c
int a = 0; // 全局初始化区
char *p1; // 全局未初始化区

void main() {
    int b;  // 栈
    char s[] = "abc";  // s 在栈，"abc\0" 在文字常量区
    char *p2;  // 栈
    char *p3 = "123456";  // p3 在栈，"123456\0" 在文字常量区
    static int c = 0;   // 全局区
    p1 = (char *) malloc(10);  // p1 在栈，分配的 10 个字节在堆
    p2 = (char *) malloc(20);  // p2 在栈，分配的 10 个字节在堆
    strcpy(p1, "123456");  // ”123456“ 在文字常量区，编译器可能会有优化为和 p3 的指向同一块区域
}
```

示例2：

```c
char *f() {
    char s[4] = {'1', '2', '3', '0'};  // s 数组存放在栈上
    return s; // 返回 s 数组的地址，但程序运行完 s 数组就释放了
}

void main() {
    char *s;
    s = f();
    printf(%s, s);  // 打印出来乱码。因为 s 所指向地址已经没有数据
}
```

### 2. C++ 中内存分配

- 栈：由编译器自动分配和释放。通常存放**局部变量**和**函数参数**

- 堆：由 malloc 等分配的内存块，和堆十分类似，不过它由 free 来结束自己的生命

- 自由存储区：由 new 分配的内存块，由应用程序控制申请和释放。如果程序员没有释放掉，那么程序结束后，操作系统会自动回收

  > 内存泄漏不是系统无法回收那片内存，而是你自己的应用程序无法使用那片内存。当你程序结束时，你所有分配的内存自动都被系统回收，不存在泄漏问题。但是在你**程序的生命期内**，如果你分配的内存都不回收，你将很快没内存使用

- 全局/静态存储区：**全局变量**和**静态变量**被分配到同一块内存中。在 C 语言中，全局变量又分为初始化和未初始化的，在 C++ 里面没有这个区分了，它们共用同一块内存区。

- 常量存储区：这是一块特殊的存储区，他们里面存放的是常量，不允许修改（非正当手段可以修改）



**《Unix 环境高级编程》中提出 C 程序的内存布局： Text、Data、BSS、Stack，Heap**

- Text 是程序的代码段
- Data 是程序中初始化了的全局、静态数据变量
- BSS 是程序中未初始化的全局/静态数据变量。即使全局、静态数据变量初始化为 0 仍然是属于 BSS 段 （未初始化的数据段）
- Stack 是程序中的局部变量，栈向下，向低地址方向增长
- Heap 是 malloc 调用动态分配的内存，堆向上，向向高地址方向增长

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230313101133517.png" alt="image-20230313101133517" style="zoom: 60%;" />

详细参看《[C++ 堆区，栈区，数据段，bss段，代码区](https://blog.csdn.net/JACKSONMHLK/article/details/114392343)》



## 三、GCC

### 1. GCC 工作流程

![image-20230322212020075](D:\Data\笔记\c++\c++基础知识.assets\image-20230322212020075.png)

### 2. GCC 编译选项

| GCC 编译选项                            | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| -E                                      | 预处理指定的源文件，不进行编译                               |
| -S                                      | 编译指定的源文件，但是不进行汇编                             |
| -c                                      | 编译、汇编指定的源文件，但是不进行链接                       |
| [file2] -o [file1] / -o [file1] [file2] | 将文件 file2 编译成可执行文件 file1                          |
| -I directorcy                           | （大写 i ）指定 include 包含文件的搜索目录                   |
| -g                                      | 在编译的时候，生成调试信息，该程序可以被调试器调试           |
| -D                                      | 在程序编译的时候，指定一个宏                                 |
| -w                                      | 不生成任何警告信息                                           |
| -Wall                                   | 生成所有警告信息                                             |
| -On                                     | n的取值范围：0~3。编译器的优化选项的4个级别，-O0表 示没有优化，-O1为缺省值，-O3优化级别最高 |
| -l                                      | （小写 L）在程序编译的时候，指定使用的库                     |
| -L                                      | 指定编译的时候，搜索的库的路径                               |
| -fPIC/fpic                              | 生成与位置无关的代码                                         |
| -shared                                 | 生成共享目标文件，通常用在建立共享库时                       |
| -std                                    | 指定C方言，如:-std=c99，gcc默认的方言是GNU C                 |

### 3. GCC 和 G++ 的区别

gcc 和 g++ 都是 GNU（组织）的一个编译器。

**误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码**。

两者都可以，请注意： 

- 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 

- 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 

- 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的

**误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会** 

实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释

如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则， 就是已定义 

**误区三：编译只能用 gcc，链接只能用 g++**

- 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++。
- gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价



## 四、库文件

### 1. 什么是库

库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 

库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。

库文件有两种，静态库和动态库（共享库），区别是：静**态库在程序的链接阶段被复制到了程序中**；**动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用**。

库的好处

① 代码保密  ②方便部署和分发

静态库: GCC 进行链接时，会把静态库中代码打包到可执行程序中

动态库: GCC 进行链接时，动态库的代码不会被打包到可执行程序中

程序启动之后，动态库会被动态加载到内存中，通过  ldd （list dynamic dependencies）命令检查动态库依赖关系

**如何定位共享库文件呢？**

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要**系统的动态载入器来获取该绝对路径**。对于 elf 格式的可执行程序，是由 ld-linux.so 来完成的，它先后搜索 elf 文件的 DT_ RPATH 段->环境变量 LD_LIBRARY_PATH 一> /etc/ld.so.cache 文件列表 一> /lib/, /usr/lib 目录找到库文件后将其载入内存。

### 2. 静态库的制作

**命名规则**

- Linux：libxxx.a
  - lib：前缀（固定）
  - xxx：库的名字，自己起
  - .a：后缀（固定）
- Windows：libxxx.lib

**静态库的制作**

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323163110332.png" alt="image-20230323163110332" style="zoom:67%;" />

- gcc 获得 .o 文件

- 将 .o 文件打包，使用 ar 工具（archive）

  ```shell
  ar rcs libxxx.a xxx.o xxx.o
  # r - 将文件插入备存文件中
  # c - 建立备存文件
  # s - 索引
  ```

### 3. 动态库的制作

**命名规则**

- Linux：libxxx.so
  - lib：前缀（固定）
  - xxx：库的名字，自己起
  - .so：后缀（固定）
- Windows：libxxx.dll

**动态库的制作**

- gcc 获得 .o 文件，得到和位置无关的代码

  ```shell
  gcc -c -fpic/-fPIC a.c b.c
  ```

- gcc 得到动态库

  ```shell
  gcc -shared a.o b.o -o libcalc.so
  ```

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323163144929.png" alt="image-20230323163144929" style="zoom:67%;" />

### 4. 静态库和动态库的对比

**程序编译成可执行程序的过程**

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323162838236.png" alt="image-20230323162838236" style="zoom: 67%;" />

**静态库的优缺点**

- 优点
  - 静态库被打包到应用程序中加载速度快
  - 发布程序无需提供静态库，移植方便
- 缺点
  - 消耗系统资源，浪费内存
  - 更新、部署、发布麻烦

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323171354110.png" alt="image-20230323171354110" style="zoom:67%;" />

**动态库的优缺点**

- 优点
  - 可以实现进程间资源共享（共享库）
  - 更新、部署、发布简单
  - 可以控制何时加载动态库
- 缺点
  - 加载速度比静态库慢
  - 发布程序时需要提供依赖的动态库

<img src="D:\Data\笔记\c++\c++基础知识.assets\image-20230323171909546.png" alt="image-20230323171909546" style="zoom:67%;" />



